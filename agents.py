"""
Sistema de 4 Agentes Independentes para Debate Fla-Flu
Seguindo Google ADK com protocolo A2A
"""

import os
import time
import json
import requests
from datetime import datetime, timedelta
from typing import Dict, Any, List
import google.generativeai as genai
from dotenv import load_dotenv

# Carrega vari√°veis do .env
load_dotenv()

# Configura√ß√£o da API
GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')
if GOOGLE_API_KEY:
    genai.configure(api_key=GOOGLE_API_KEY)

class BaseAgent:
    """Classe base para todos os agentes ADK"""
    
    def __init__(self, name: str, role: str, model: str = "gemini-2.0-flash"):
        self.name = name
        self.role = role
        self.model = model
        self.conversation_history = []
        self.tools = []
        self.active = False
        
        # Inicializa cliente Gemini
        if GOOGLE_API_KEY:
            self.client = genai.GenerativeModel(model)
        else:
            self.client = None
    
    def send_message(self, message: str, context: Dict = None) -> Dict[str, Any]:
        """Envia mensagem via protocolo A2A"""
        try:
            if not self.client:
                return {
                    "status": "error",
                    "agent": self.name,
                    "message": "API key n√£o configurada",
                    "timestamp": time.time()
                }
            
            # Adiciona contexto se fornecido
            full_prompt = message
            if context:
                full_prompt = f"Contexto: {json.dumps(context, ensure_ascii=False)}\n\nMensagem: {message}"
            
            # Envia para Gemini
            response = self.client.generate_content(full_prompt)
            response_text = response.text
            
            # Log da conversa
            self.conversation_history.append({
                "input": message,
                "output": response_text,
                "timestamp": time.time()
            })
            
            return {
                "status": "success",
                "agent": self.name,
                "message": response_text,
                "timestamp": time.time()
            }
            
        except Exception as e:
            return {
                "status": "error",
                "agent": self.name,
                "message": f"Erro: {str(e)}",
                "timestamp": time.time()
            }
    
    def get_status(self) -> Dict[str, Any]:
        """Retorna status atual do agente"""
        return {
            "name": self.name,
            "role": self.role,
            "active": self.active,
            "messages_count": len(self.conversation_history),
            "tools_available": len(self.tools)
        }

class SupervisorAgent(BaseAgent):
    """Agente Supervisor - Coordena debate e analisa resultados"""
    
    def __init__(self):
        super().__init__("Supervisor", "Coordenador de Debate")
        self.debate_duration = 0
        self.debate_start_time = None
        self.current_speaker = None
        self.turn_duration = 0
        self.flamengo_time = 0
        self.fluminense_time = 0
        
        self.system_prompt = """
        Voc√™ √© um SUPERVISOR DE DEBATE especialista em:
        - Ret√≥rica e persuas√£o
        - Psicologia cognitiva
        - Lingu√≠stica aplicada
        - An√°lise l√≥gica de argumentos
        
        Suas fun√ß√µes:
        1. Coordenar tempo do debate (50% para cada time)
        2. Analisar qualidade argumentativa
        3. Determinar vencedor baseado em crit√©rios t√©cnicos
        4. Manter neutralidade absoluta
        
        SEMPRE mantenha tom profissional e imparcial.
        """
    
    def start_debate(self, duration_minutes: int) -> Dict[str, Any]:
        """Inicia o debate com dura√ß√£o espec√≠fica"""
        try:
            self.debate_duration = duration_minutes
            self.debate_start_time = time.time()
            self.turn_duration = (duration_minutes * 60) / 2  # 50% para cada
            self.active = True
            
            message = f"""
üéØ **DEBATE OFICIAL INICIADO**

‚è±Ô∏è **Configura√ß√£o:**
‚Ä¢ Dura√ß√£o total: {duration_minutes} minutos
‚Ä¢ Tempo por time: {self.turn_duration/60:.1f} minutos cada
‚Ä¢ In√≠cio: {datetime.now().strftime('%H:%M:%S')}

‚öñÔ∏è **Crit√©rios de Avalia√ß√£o:**
1. **For√ßa dos Argumentos** (40%)
2. **Evid√™ncias e Dados** (30%) 
3. **Persuas√£o e Ret√≥rica** (20%)
4. **Consist√™ncia L√≥gica** (10%)

üé≤ **Sorteio:** FLAMENGO inicia o debate!

üî¥ Agente Flamengo, voc√™ tem {self.turn_duration/60:.1f} minutos. Comece sua argumenta√ß√£o!
            """
            
            self.current_speaker = "Flamengo"
            
            return self.send_message(message)
            
        except Exception as e:
            return {
                "status": "error",
                "agent": self.name,
                "message": f"Erro ao iniciar debate: {str(e)}",
                "timestamp": time.time()
            }
    
    def analyze_final_debate(self, debate_history: List[Dict]) -> Dict[str, Any]:
        """An√°lise final especializada do debate"""
        try:
            # Prepara dados para an√°lise
            flamengo_messages = [msg for msg in debate_history if "flamengo" in msg.get("agent", "").lower()]
            fluminense_messages = [msg for msg in debate_history if "fluminense" in msg.get("agent", "").lower()]
            
            analysis_prompt = f"""
            Como especialista em debate, psicologia, lingu√≠stica e ret√≥rica, analise este debate:
            
            ARGUMENTOS FLAMENGO ({len(flamengo_messages)} mensagens):
            {json.dumps([msg.get("message", "") for msg in flamengo_messages], ensure_ascii=False, indent=2)}
            
            ARGUMENTOS FLUMINENSE ({len(fluminense_messages)} mensagens):
            {json.dumps([msg.get("message", "") for msg in fluminense_messages], ensure_ascii=False, indent=2)}
            
            Forne√ßa an√°lise detalhada considerando:
            1. For√ßa argumentativa e l√≥gica
            2. Uso de evid√™ncias e dados
            3. T√©cnicas persuasivas empregadas
            4. Consist√™ncia e coer√™ncia
            5. Impacto ret√≥rico
            
            Declare um VENCEDOR com justificativa t√©cnica.
            """
            
            return self.send_message(analysis_prompt)
            
        except Exception as e:
            return {
                "status": "error",
                "agent": self.name,
                "message": f"Erro na an√°lise: {str(e)}",
                "timestamp": time.time()
            }
    
    def get_time_remaining(self) -> Dict[str, Any]:
        """Retorna tempo restante do debate"""
        if not self.debate_start_time:
            return {"total": 0, "current_turn": 0}
        
        elapsed = time.time() - self.debate_start_time
        total_remaining = max(0, (self.debate_duration * 60) - elapsed)
        
        return {
            "total_remaining": total_remaining,
            "current_speaker": self.current_speaker,
            "turn_time_used": min(elapsed, self.turn_duration) if self.current_speaker == "Flamengo" else max(0, elapsed - self.turn_duration)
        }

class FlamengoAgent(BaseAgent):
    """Agente Torcedor do Flamengo"""
    
    def __init__(self):
        super().__init__("Torcedor Flamengo", "Defensor Rubro-Negro")
        
        self.persuasion_text = """
        üî¥‚ö° **FLAMENGO - A NA√á√ÉO RUBRO-NEGRA** ‚ö°üî¥
        
        Somos o MAIOR clube do Brasil! Com mais de 40 milh√µes de torcedores apaixonados, 
        o Flamengo n√£o √© apenas um time - √© um sentimento que move o pa√≠s!
        
        üèÜ **NOSSOS T√çTULOS FALAM POR SI:**
        ‚Ä¢ 8 Brasileir√µes (mais que qualquer rival carioca)
        ‚Ä¢ 3 Libertadores (incluindo as gloriosas de 2019 e 2022)
        ‚Ä¢ 1 Mundial (1981 - Zico eterno!)
        ‚Ä¢ Mais de 35 Cariocas
        
        ‚≠ê **ESTRELAS MUNDIAIS:**
        De Zico a Vin√≠cius Jr., formamos e revelamos os maiores talentos do futebol mundial.
        Gabigol, Pedro, Arrascaeta - nosso elenco atual √© FENOMENAL!
        
        üí™ **FOR√áA INCOMPAR√ÅVEL:**
        Somos o time com maior torcida, maior estrutura, maiores investimentos e maior paix√£o.
        O Maracan√£ vira um CALDEIR√ÉO quando jogamos!
        
        üî• Uma vez Flamengo, sempre Flamengo! MENGO √© RA√áA, √© GARRA, √© VIT√ìRIA!
        """
        
        self.system_prompt = f"""
        {self.persuasion_text}
        
        Voc√™ √© um TORCEDOR FAN√ÅTICO do Flamengo. Sua miss√£o:
        1. Defender o Flamengo com PAIX√ÉO e DADOS
        2. Usar argumentos emocionais E factuais
        3. Provocar o rival com intelig√™ncia
        4. Solicitar dados ao pesquisador quando necess√°rio
        5. NUNCA admitir derrota - somos SUPERIORES!
        
        Mantenha o tom apaixonado mas respeitoso. Use emojis do Flamengo: üî¥‚ö°üèÜ
        """
    
    def get_initial_argument(self) -> Dict[str, Any]:
        """Retorna argumento inicial persuasivo"""
        prompt = f"""
        {self.system_prompt}
        
        Apresente seu argumento inicial DEMOLIDOR sobre por que o Flamengo √© superior ao Fluminense.
        Use dados, emo√ß√£o e persuas√£o. Seja convincente e apaixonado!
        """
        
        return self.send_message(prompt)
    
    def counter_argument(self, opponent_message: str, research_data: str = None) -> Dict[str, Any]:
        """Gera contra-argumento baseado na mensagem do oponente"""
        context = {
            "opponent_argument": opponent_message,
            "research_data": research_data if research_data else "Nenhum dado adicional"
        }
        
        prompt = f"""
        {self.system_prompt}
        
        O torcedor do Fluminense disse: "{opponent_message}"
        
        CONTRA-ATAQUE com argumentos devastadores! Use paix√£o, dados e l√≥gica para
        destronar completamente esse argumento fraco. Se necess√°rio, solicite dados
        ao pesquisador mencionando "PESQUISADOR: [sua solicita√ß√£o]".
        """
        
        return self.send_message(prompt, context)

class FluminenseAgent(BaseAgent):
    """Agente Torcedor do Fluminense"""
    
    def __init__(self):
        super().__init__("Torcedor Fluminense", "Defensor Tricolor")
        
        self.persuasion_text = """
        üíöü§ç‚ù§Ô∏è **FLUMINENSE - TRADI√á√ÉO E ELEG√ÇNCIA** ‚ù§Ô∏èü§çüíö
        
        Somos o time mais TRADICIONAL do Rio de Janeiro! Fundado em 1902, 
        carregamos mais de 120 anos de hist√≥ria, classe e futebol-arte!
        
        üèÜ **NOSSA GLORIOSA HIST√ìRIA:**
        ‚Ä¢ 4 Brasileir√µes conquistados com muito suor
        ‚Ä¢ CAMPE√ïES DA LIBERTADORES 2023 (ATUAL CAMPE√ÉO!)
        ‚Ä¢ Mais de 30 Cariocas com futebol de qualidade
        ‚Ä¢ Formamos os maiores craques da Sele√ß√£o
        
        ‚≠ê **ESCOLA DE CRAQUES:**
        Didi, Carlos Alberto Torres, Rivellino, Fred - revelamos LENDAS do futebol!
        Germ√°n Cano, Ganso, Jhon Arias - nosso atual elenco √© T√âCNICO e QUALIFICADO!
        
        üé≠ **FUTEBOL-ARTE:**
        N√£o jogamos apenas futebol - fazemos ARTE em campo! 
        Temos estilo, eleg√¢ncia e a torcida mais refinada do Brasil!
        
        ‚ú® Somos tricolores de cora√ß√£o! FLU √© TRADI√á√ÉO, √© CLASSE, √© CONQUISTA!
        """
        
        self.system_prompt = f"""
        {self.persuasion_text}
        
        Voc√™ √© um TORCEDOR ORGULHOSO do Fluminense. Sua miss√£o:
        1. Defender o Fluminense com ELEG√ÇNCIA e TRADI√á√ÉO
        2. Usar a rica hist√≥ria e conquistas recentes
        3. Destacar nossa superioridade t√©cnica e cultural
        4. Solicitar dados ao pesquisador quando necess√°rio
        5. Mostrar nossa CLASSE superior ao rival
        
        Mantenha tom elegante mas firme. Use emojis do Fluminense: üíöü§ç‚ù§Ô∏è‚ú®üèÜ
        """
    
    def get_initial_argument(self) -> Dict[str, Any]:
        """Retorna argumento inicial persuasivo"""
        prompt = f"""
        {self.system_prompt}
        
        Apresente seu argumento inicial ELEGANTE sobre por que o Fluminense √© superior ao Flamengo.
        Use nossa tradi√ß√£o, conquistas recentes (Libertadores 2023!) e superioridade t√©cnica.
        Seja convincente com classe!
        """
        
        return self.send_message(prompt)
    
    def counter_argument(self, opponent_message: str, research_data: str = None) -> Dict[str, Any]:
        """Gera contra-argumento baseado na mensagem do oponente"""
        context = {
            "opponent_argument": opponent_message,
            "research_data": research_data if research_data else "Nenhum dado adicional"
        }
        
        prompt = f"""
        {self.system_prompt}
        
        O torcedor do Flamengo disse: "{opponent_message}"
        
        RESPONDA com CLASSE e ELEG√ÇNCIA! Use nossa tradi√ß√£o, conquistas recentes e
        superioridade t√©cnica para desmontar esse argumento. Se necess√°rio, solicite dados
        ao pesquisador mencionando "PESQUISADOR: [sua solicita√ß√£o]".
        """
        
        return self.send_message(prompt, context)

class ResearcherAgent(BaseAgent):
    """Agente Pesquisador - Busca dados na internet"""
    
    def __init__(self):
        super().__init__("Pesquisador", "Especialista em Dados")
        
        self.system_prompt = """
        Voc√™ √© um PESQUISADOR NEUTRO e OBJETIVO especializado em futebol brasileiro.
        
        Suas fun√ß√µes:
        1. Buscar dados FACTUAIS sobre Flamengo e Fluminense
        2. Fornecer estat√≠sticas VERIFIC√ÅVEIS
        3. Manter NEUTRALIDADE absoluta
        4. Responder rapidamente √†s solicita√ß√µes
        5. Indicar fontes quando poss√≠vel
        
        NUNCA tome partido - seja sempre imparcial e t√©cnico!
        """
    
    def search_data(self, query: str, requesting_agent: str) -> Dict[str, Any]:
        """Busca dados sobre os times (simulado - em produ√ß√£o usaria API real)"""
        
        # Base de dados simulada (em produ√ß√£o seria busca real na internet)
        database = {
            "flamengo_titulos": {
                "brasileirao": "8 t√≠tulos (1980, 1982, 1983, 1987, 1992, 2009, 2019, 2020)",
                "libertadores": "3 t√≠tulos (1981, 2019, 2022)",
                "mundial": "1 t√≠tulo (1981)",
                "carioca": "37 t√≠tulos estaduais"
            },
            "fluminense_titulos": {
                "brasileirao": "4 t√≠tulos (1970, 1984, 2010, 2012)",
                "libertadores": "1 t√≠tulo (2023 - ATUAL CAMPE√ÉO)",
                "carioca": "32 t√≠tulos estaduais",
                "copa_brasil": "1 t√≠tulo (2007)"
            },
            "flamengo_torcida": "Aproximadamente 43 milh√µes de torcedores (Datafolha 2023)",
            "fluminense_tradicao": "Clube mais antigo do Rio de Janeiro (fundado em 1902)",
            "flamengo_investimentos": "Maior or√ßamento do futebol brasileiro em 2023",
            "fluminense_base": "Uma das melhores categorias de base do Brasil"
        }
        
        # Simula busca baseada na query
        results = []
        query_lower = query.lower()
        
        for key, value in database.items():
            if any(term in key for term in query_lower.split()):
                results.append(f"‚Ä¢ {key.replace('_', ' ').title()}: {value}")
        
        if not results:
            results.append("Dados n√£o encontrados para esta consulta espec√≠fica.")
        
        research_report = f"""
üìä **PESQUISA SOLICITADA POR:** {requesting_agent}
üîç **CONSULTA:** {query}
‚è∞ **TIMESTAMP:** {datetime.now().strftime('%H:%M:%S')}

üìà **RESULTADOS ENCONTRADOS:**
{chr(10).join(results)}

üîó **FONTES:** Datafolha, CBF, CONMEBOL, imprensa esportiva
‚öñÔ∏è **STATUS:** Dados verificados e neutros
        """
        
        context = {
            "query": query,
            "requesting_agent": requesting_agent,
            "results_count": len(results)
        }
        
        return self.send_message(research_report, context)
    
    def quick_fact(self, topic: str) -> Dict[str, Any]:
        """Retorna fato r√°pido sobre um t√≥pico"""
        prompt = f"""
        {self.system_prompt}
        
        Forne√ßa um FATO R√ÅPIDO e OBJETIVO sobre: {topic}
        
        Seja conciso, factual e neutro. Inclua dados num√©ricos se dispon√≠vel.
        """
        
        return self.send_message(prompt)

# Sistema de comunica√ß√£o A2A
class A2AProtocol:
    """Protocolo de comunica√ß√£o Agent-to-Agent"""
    
    def __init__(self):
        self.agents = {
            "supervisor": SupervisorAgent(),
            "flamengo": FlamengoAgent(), 
            "fluminense": FluminenseAgent(),
            "researcher": ResearcherAgent()
        }
        self.message_log = []
        self.active_debate = False
    
    def send_message(self, from_agent: str, to_agent: str, message: str, context: Dict = None) -> Dict[str, Any]:
        """Envia mensagem entre agentes via protocolo A2A"""
        
        if from_agent not in self.agents or to_agent not in self.agents:
            return {"status": "error", "message": "Agente n√£o encontrado"}
        
        # Log da comunica√ß√£o A2A
        a2a_message = {
            "from": from_agent,
            "to": to_agent,
            "message": message,
            "context": context or {},
            "timestamp": time.time(),
            "protocol": "A2A-v1.0"
        }
        
        self.message_log.append(a2a_message)
        
        # Processa mensagem no agente destinat√°rio
        target_agent = self.agents[to_agent]
        response = target_agent.send_message(message, context)
        
        return {
            "status": "success",
            "a2a_message": a2a_message,
            "response": response
        }
    
    def get_agent(self, agent_name: str) -> BaseAgent:
        """Retorna inst√¢ncia do agente"""
        return self.agents.get(agent_name)
    
    def get_system_status(self) -> Dict[str, Any]:
        """Retorna status completo do sistema"""
        return {
            "agents_loaded": len(self.agents),
            "total_messages": len(self.message_log),
            "active_debate": self.active_debate,
            "agents_status": {name: agent.get_status() for name, agent in self.agents.items()}
        }

# Inst√¢ncia global do sistema A2A
debate_system = A2AProtocol()

# Fun√ß√µes de conveni√™ncia para acesso aos agentes
def get_supervisor() -> SupervisorAgent:
    return debate_system.get_agent("supervisor")

def get_flamengo_agent() -> FlamengoAgent:
    return debate_system.get_agent("flamengo")

def get_fluminense_agent() -> FluminenseAgent:
    return debate_system.get_agent("fluminense")

def get_researcher() -> ResearcherAgent:
    return debate_system.get_agent("researcher")

def get_system_status() -> Dict[str, Any]:
    return debate_system.get_system_status()